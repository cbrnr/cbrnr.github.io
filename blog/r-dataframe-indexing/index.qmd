---
title: Indexing data frames in R
date: 2023-11-17
description: TODO!
categories:
  - R
  - Basics
---

## Introduction

Data frames are one of the most important data structures for representing tabular data. Base R includes the tried and tested `data.frame` type, which is technically a list of equal-length vectors (where each vector corresponds to a column in the data frame). The [tibble](https://tibble.tidyverse.org) package (part of the [Tidyverse](https://www.tidyverse.org)) offers a slightly tweaked data frame type called `tibble`. In most situations, `data.frame` and `tibble` are interchangeable. However, there are subtle differences in the context of indexing, which I will highlight in this post.


## Indexing vectors

In general, R uses a pair of square brackets `[]` for indexing specific elements in a given object. This is rather straightforward for simple vectors. Let's look at an example:

```{r}
(v = c("A", "B", "C", "D"))
```

This vector has four elements, and we can grab a specific element by providing the corresponding index between the square brackets. For example, here's how we can get the second element of `v`:

```{r}
v[2]  # second element
```

:::{.callout-note}
R uses 1-based indexing, so the index of the first element is `1`, followed by `2` for the second element, and so on.
:::

If we want to index two or more elements, we need to wrap the desired positions within `c()`, because R always expects *a single vector* within the square brackets:

```{r}
v[c(2, 4)]  # second and fourth element
```

Negative indices grab all elements except for those specified by the negative numbers. For example, to get all elements except for the third one:

```{r}
v[-3]  # all elements except the third
```

There is no special syntax for indexing the last element of a vector, so we have to write:

```{r}
v[length(v)]  # last element
```


## Indexing data frames

Indexing data frames is slightly more challenging, mainly because there is a multitude of available (and partly redundant) options. We'll start with a small data frame `df` consisting of four rows and three columns:

```{r}
(df = data.frame(first=1:4, second=seq(pi, pi + 3), third=LETTERS[1:4]))
```

This is a classic `data.frame`, so let's also create a `tibble` with identical contents:

```{r}
(tf = tibble::as_tibble(df))
```


## Selecting entire columns

Selecting one ore more columns is one of the basic building blocks of any data analysis pipeline. In the following examples, we will explore different options to select the second column (named `"second"`).


### The `$` operator

We'll start with the `$` operator, which extracts a column by name as follows:

```{r}
df$second  # vector
df$"second"  # vector
```

We can enclose the desired column name in quotes, but the first variant without quotes is more common. In either case, R returns the single column as a basic vector.

The `$` notation is convenient for interactive exploration, because we don't have to type a lot of extra characters (except for the `$` sign). In addition, RStudio offers auto-completion of matching column names in its console.

:::{.callout-important}
Indexing with `$` performs partial matching. This means that R will return the first column that partially matches the given name, for example:

```{r}
df$s  # extracts column "second"
```

R will happily return `df$second` in this example. You can learn more about `$` by typing `` ?`$` `` in the interactive console.
:::

It is very easy to shoot yourself in the foot with partial matching, especially if you make a typo. Therefore, I strongly advise against using the `$` notation. There are plenty of better options avaible, which we will discuss next.


### The list indexing operator `[[]]`

```{r}
df[["second"]]  # vector
df[["s", exact=FALSE]]  # vector, if you really want partial matching
df[[2]]  # vector
df[, "second"]  # vector
df[, 2]  # vector
df[, "second", drop=FALSE]  # data.frame
df[, 2, drop=FALSE]  # data.frame
df["second"]  # data.frame
df[2]  # data.frame

tf$second  # vector
tf$"second"  # vector
tf$s  # returns NULL (partial matching does not work)
tf[["second"]]  # vector
tf[[2]]  # vector
tf[, "second"]  # tibble
tf[, 2]  # tibble
tf[, "second", drop=TRUE]  # vector
tf[, 2, drop=TRUE]  # vector
tf["second"]  # tibble
tf[2]  # tibble


# Indexing multiple columns
#   "second" and "third" (columns 2 and 3)
df[, c("second", "third")]
df[, c(2, 3)]
df[c("second", "third")]
df[c(2, 3)]

tf[, c("second", "third")]
tf[, c(2, 3)]
tf[c("second", "third")]
tf[c(2, 3)]
```


## Selecting entire rows

```{r}
# Indexing a single row
#   row 2
df[2, ]  # data.frame
unlist(df[2, ])  # named vector
unname(unlist(df[2, ]))  # vector
tf[2, ]  # tibble
unlist(tf[2, ])  # named vector
unname(unlist(tf[2, ]))  # vector

# Indexing multiple rows
#   rows 2 and 3
df[c(2, 3), ]  # data.frame
tf[c(2, 3), ]  # tibble
```
